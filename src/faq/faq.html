<section id="builtin-operators-and-functions">
  <section id="walk">
    <h3><code>walk(f)</code></h3>
    <p>
      The <code>walk(f)</code> function applies f recursively to every component of the input entity. When an
      array is encountered, f is first applied to its elements and then to the array itself; when an object is
      encountered, f is first applied to all the values and then to the object. In practice, f will usually
      test
      the type of its input, as illustrated in the following examples. The first example highlights the
      usefulness
      of processing the elements of an array of arrays before processing the array itself. The second example
      shows how all the keys of all the objects within the input can be considered for alteration.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example70" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">walk(if type == "array" then sort else . end)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[4, 1, 7], [8, 5, 2], [3, 6, 9]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[[1,4,7],[2,5,8],[3,6,9]]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">
              walk( if type == "object" then with_entries( .key |= sub( "^_+"; "") ) else . end )
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[ { "_a": { "__b": 2 } } ]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[{"a":{"b":2}}]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="$env-env" style="display: none">
    <h3><code>$ENV</code>, <code>env</code></h3>
    <p>
      <code>$ENV</code> is an object representing the environment variables as set when the jq program
      started.
    </p>
    <p><code>env</code> outputs an object representing jq's current environment.</p>
    <p>At the moment there is no builtin for setting environment variables.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example71" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">$ENV.PAGER</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"less"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">env.PAGER</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"less"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="transpose">
    <h3><code>transpose</code></h3>
    <p>
      Transpose a possibly jagged matrix (an array of arrays). Rows are padded with nulls so the result is
      always
      rectangular.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example72" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">transpose</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[1], [2,3]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[[1,2],[null,3]]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="bsearch">
    <h3><code>bsearch(x)</code></h3>
    <p>
      <code>bsearch(x)</code> conducts a binary search for x in the input array. If the input is sorted and
      contains x, then <code>bsearch(x)</code> will return its index in the array; otherwise, if the array is
      sorted, it will return (-1 - ix) where ix is an insertion point such that the array would still be
      sorted
      after the insertion of x at ix. If the array is not sorted, <code>bsearch(x)</code> will return an
      integer
      that is probably of no interest.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example73" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">bsearch(0)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[0,1]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">0</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">bsearch(0)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">-1</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">bsearch(4) as $ix | if $ix &lt; 0 then .[-(1+$ix)] = 4 else .
              end
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,2,3,4]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="string-interpolation">
    <h3>String interpolation: <code>\(exp)</code></h3>
    <p>
      Inside a string, you can put an expression inside parens after a backslash. Whatever the expression
      returns
      will be interpolated into the string.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example74" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">"The input was \(.), which is one less than \(.+1)"</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">42</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"The input was 42, which is one less than 43"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="convert-to-from-json">
    <h3>Convert to/from JSON</h3>
    <p>
      The <code>tojson</code> and <code>fromjson</code> builtins dump values as JSON texts or parse JSON texts
      into values, respectively. The <code>tojson</code> builtin differs from <code>tostring</code> in that
      <code>tostring</code> returns strings unmodified, while <code>tojson</code> encodes strings as JSON
      strings.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example75" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[]|tostring]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1, "foo", ["foo"]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">["1","foo","[\"foo\"]"]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[]|tojson]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1, "foo", ["foo"]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">["1","\"foo\"","[\"foo\"]"]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[]|tojson|fromjson]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1, "foo", ["foo"]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,"foo",["foo"]]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="format-strings-and-escaping">
    <h3>Format strings and escaping</h3>
    <p>
      The <code>@foo</code> syntax is used to format and escape strings, which is useful for building URLs,
      documents in a language like HTML or XML, and so forth. <code>@foo</code> can be used as a filter on its
      own, the possible escapings are:
    </p>
    <ul>
      <li><code>@text</code>:</li>
    </ul>
    <p>Calls <code>tostring</code>, see that function for details.</p>
    <ul>
      <li><code>@json</code>:</li>
    </ul>
    <p>Serializes the input as JSON.</p>
    <ul>
      <li><code>@html</code>:</li>
    </ul>
    <p>
      Applies HTML/XML escaping, by mapping the characters
      <code>&lt;&gt;&amp;'"</code> to their entity equivalents <code>&amp;lt;</code>, <code>&amp;gt;</code>,
      <code>&amp;amp;</code>, <code>&amp;apos;</code>, <code>&amp;quot;</code>.
    </p>
    <ul>
      <li><code>@uri</code>:</li>
    </ul>
    <p>Applies percent-encoding, by mapping all reserved URI characters to a <code>%XX</code> sequence.</p>
    <ul>
      <li><code>@csv</code>:</li>
    </ul>
    <p>
      The input must be an array, and it is rendered as CSV with double quotes for strings, and quotes escaped
      by
      repetition.
    </p>
    <ul>
      <li><code>@tsv</code>:</li>
    </ul>
    <p>
      The input must be an array, and it is rendered as TSV (tab-separated values). Each input array will be
      printed as a single line. Fields are separated by a single tab (ascii <code>0x09</code>). Input
      characters
      line-feed (ascii <code>0x0a</code>), carriage-return (ascii <code>0x0d</code>), tab (ascii
      <code>0x09</code>) and backslash (ascii <code>0x5c</code>) will be output as escape sequences
      <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\\</code> respectively.
    </p>
    <ul>
      <li><code>@sh</code>:</li>
    </ul>
    <p>
      The input is escaped suitable for use in a command-line for a POSIX shell. If the input is an array, the
      output will be a series of space-separated strings.
    </p>
    <ul>
      <li><code>@base64</code>:</li>
    </ul>
    <p>The input is converted to base64 as specified by RFC 4648.</p>
    <ul>
      <li><code>@base64d</code>:</li>
    </ul>
    <p>
      The inverse of <code>@base64</code>, input is decoded as specified by RFC 4648. Note\: If the decoded
      string
      is not UTF-8, the results are undefined.
    </p>
    <p>
      This syntax can be combined with string interpolation in a useful way. You can follow a
      <code>@foo</code> token with a string literal. The contents of the string literal will <em>not</em> be
      escaped. However, all interpolations made inside that string literal will be escaped. For instance,
    </p>
    <pre><code>@uri "https://www.google.com/search?q=\(.search)"
</code></pre>
    <p>
      will produce the following output for the input
      <code>{"search":"what is jq?"}</code>:
    </p>
    <pre><code>"https://www.google.com/search?q=what%20is%20jq%3F"
</code></pre>
    <p>
      Note that the slashes, question mark, etc. in the URL are not escaped, as they were part of the string
      literal.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example76" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">@html</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"This works if x &lt; y"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"This works if x &amp;lt; y"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">@sh "echo \(.)"</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"O'Hara's Ale"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"echo 'O'\\''Hara'\\''s Ale'"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">@base64</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"This is a message"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"VGhpcyBpcyBhIG1lc3NhZ2U="</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">@base64d</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"VGhpcyBpcyBhIG1lc3NhZ2U="</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"This is a message"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="dates">
    <h3>Dates</h3>
    <p>
      jq provides some basic date handling functionality, with some high-level and low-level builtins. In all
      cases these builtins deal exclusively with time in UTC.
    </p>
    <p>
      The <code>fromdateiso8601</code> builtin parses datetimes in the ISO 8601 format to a number of seconds
      since the Unix epoch (1970-01-01T00:00:00Z). The <code>todateiso8601</code> builtin does the inverse.
    </p>
    <p>
      The <code>fromdate</code> builtin parses datetime strings. Currently <code>fromdate</code> only supports
      ISO
      8601 datetime strings, but in the future it will attempt to parse datetime strings in more formats.
    </p>
    <p>The <code>todate</code> builtin is an alias for <code>todateiso8601</code>.</p>
    <p>The <code>now</code> builtin outputs the current time, in seconds since the Unix epoch.</p>
    <p>
      Low-level jq interfaces to the C-library time functions are also provided: <code>strptime</code>,
      <code>strftime</code>, <code>strflocaltime</code>, <code>mktime</code>, <code>gmtime</code>, and
      <code>localtime</code>. Refer to your host operating system's documentation for the format strings used
      by
      <code>strptime</code> and <code>strftime</code>. Note: these are not necessarily stable interfaces in
      jq,
      particularly as to their localization functionality.
    </p>
    <p>
      The <code>gmtime</code> builtin consumes a number of seconds since the Unix epoch and outputs a "broken
      down
      time" representation of Greenwich Mean Time as an array of numbers representing (in this order): the
      year,
      the month (zero-based), the day of the month (one-based), the hour of the day, the minute of the hour,
      the
      second of the minute, the day of the week, and the day of the year -- all one-based unless otherwise
      stated.
      The day of the week number may be wrong on some systems for dates before March 1st 1900, or after
      December
      31 2099.
    </p>
    <p>
      The <code>localtime</code> builtin works like the <code>gmtime</code> builtin, but using the local
      timezone
      setting.
    </p>
    <p>
      The <code>mktime</code> builtin consumes "broken down time" representations of time output by
      <code>gmtime</code> and <code>strptime</code>.
    </p>
    <p>
      The <code>strptime(fmt)</code> builtin parses input strings matching the <code>fmt</code> argument. The
      output is in the "broken down time" representation consumed by <code>mktime</code> and output by
      <code>gmtime</code>.
    </p>
    <p>
      The <code>strftime(fmt)</code> builtin formats a time (GMT) with the given format. The
      <code>strflocaltime</code> does the same, but using the local timezone setting.
    </p>
    <p>
      The format strings for <code>strptime</code> and <code>strftime</code> are described in typical C
      library
      documentation. The format string for ISO 8601 datetime is <code>"%Y-%m-%dT%H:%M:%SZ"</code>.
    </p>
    <p>
      jq may not support some or all of this date functionality on some systems. In particular, the
      <code>%u</code> and <code>%j</code> specifiers for <code>strptime(fmt)</code> are not supported on
      macOS.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example77" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">fromdate</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"2015-03-05T23:51:47Z"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">1425599507</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">strptime("%Y-%m-%dT%H:%M:%SZ")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"2015-03-05T23:51:47Z"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[2015,2,5,23,51,47,4,63]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">strptime("%Y-%m-%dT%H:%M:%SZ")|mktime</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"2015-03-05T23:51:47Z"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">1425599507</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="sql-style-operators" style="display: none">
    <h3>SQL-Style Operators</h3>
    <p>jq provides a few SQL-style operators.</p>
    <ul>
      <li>INDEX(stream; index_expression):</li>
    </ul>
    <p>
      This builtin produces an object whose keys are computed by the given index expression applied to each
      value
      from the given stream.
    </p>
    <ul>
      <li>JOIN($idx; stream; idx_expr; join_expr):</li>
    </ul>
    <p>
      This builtin joins the values from the given stream to the given index. The index's keys are computed by
      applying the given index expression to each value from the given stream. An array of the value in the
      stream
      and the corresponding value from the index is fed to the given join expression to produce each result.
    </p>
    <ul>
      <li>JOIN($idx; stream; idx_expr):</li>
    </ul>
    <p>Same as <code>JOIN($idx; stream; idx_expr; .)</code>.</p>
    <ul>
      <li>JOIN($idx; idx_expr):</li>
    </ul>
    <p>
      This builtin joins the input <code>.</code> to the given index, applying the given index expression to
      <code>.</code> to compute the index key. The join operation is as described above.
    </p>
    <ul>
      <li>IN(s):</li>
    </ul>
    <p>
      This builtin outputs <code>true</code> if <code>.</code> appears in the given stream, otherwise it
      outputs
      <code>false</code>.
    </p>
    <ul>
      <li>IN(source; s):</li>
    </ul>
    <p>
      This builtin outputs <code>true</code> if any value in the source stream appears in the second stream,
      otherwise it outputs <code>false</code>.
    </p>
  </section>
  <section id="builtins">
    <h3><code>builtins</code></h3>
    <p>
      Returns a list of all builtin functions in the format
      <code>name/arity</code>. Since functions with the same name but different arities are considered
      separate
      functions, <code>all/0</code>, <code>all/1</code>, and <code>all/2</code> would all be present in the
      list.
    </p>
  </section>
</section>
<!-- SECTION -->
<section id="conditionals-and-comparisons">
  <h2>Conditionals and Comparisons</h2>
  <section id="==-!=">
    <h3><code>==</code>, <code>!=</code></h3>
    <p>
      The expression 'a == b' will produce 'true' if the results of evaluating a and b are equal (that is, if
      they
      represent equivalent JSON values) and 'false' otherwise. In particular, strings are never considered
      equal
      to numbers. In checking for the equality of JSON objects, the ordering of keys is irrelevant. If you're
      coming from JavaScript, please note that jq's <code>==</code> is like JavaScript's <code>===</code>, the
      "strict equality" operator.
    </p>
    <p>!= is "not equal", and 'a != b' returns the opposite value of 'a == b'</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example78" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">. == false</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">false</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">. == {"b": {"d": (4 + 1e-20), "c": 3}, "a":1}</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"a":1, "b": {"c": 3, "d": 4}}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.[] == 1</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1, 1.0, "1", "banana"]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">false</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">false</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="if-then-else-end">
    <h3>if-then-else-end</h3>
    <p>
      <code>if A then B else C end</code> will act the same as <code>B</code> if <code>A</code> produces a
      value
      other than false or null, but act the same as <code>C</code> otherwise.
    </p>
    <p>
      <code>if A then B end</code> is the same as <code>if A then B else . end</code>. That is, the
      <code>else</code> branch is optional, and if absent is the same as <code>.</code>. This also applies to
      <code>elif</code> with absent ending <code>else</code> branch.
    </p>
    <p>
      Checking for false or null is a simpler notion of "truthiness" than is found in JavaScript or Python,
      but it
      means that you'll sometimes have to be more explicit about the condition you want. You can't test
      whether,
      e.g. a string is empty using
      <code>if .name then A else B end</code>; you'll need something like
      <code>if .name == "" then A else B end</code> instead.
    </p>
    <p>
      If the condition <code>A</code> produces multiple results, then <code>B</code> is evaluated once for
      each
      result that is not false or null, and <code>C</code> is evaluated once for each false or null.
    </p>
    <p>
      More cases can be added to an if using
      <code>elif A then B</code> syntax.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example79" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">if . == 0 then "zero" elif . == 1 then "one" else "many" end</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">2</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"many"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id=">->=-<=-<">
    <h3><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code></h3>
    <p>
      The comparison operators <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>
      return whether their left argument is greater than, greater than or equal to, less than or equal to or
      less
      than their right argument (respectively).
    </p>
    <p>The ordering is the same as that described for <code>sort</code>, above.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example80" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">. &lt; 5</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">2</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="and-or-not">
    <h3><code>and</code>, <code>or</code>, <code>not</code></h3>
    <p>
      jq supports the normal Boolean operators <code>and</code>, <code>or</code>, <code>not</code>. They have
      the
      same standard of truth as if expressions - <code>false</code> and <code>null</code> are considered
      "false
      values", and anything else is a "true value".
    </p>
    <p>
      If an operand of one of these operators produces multiple results, the operator itself will produce a
      result
      for each input.
    </p>
    <p>
      <code>not</code> is in fact a builtin function rather than an operator, so it is called as a filter to
      which
      things can be piped rather than with special syntax, as in <code>.foo and .bar | not</code>.
    </p>
    <p>
      These three only produce the values <code>true</code> and <code>false</code>, and so are only useful for
      genuine Boolean operations, rather than the common Perl/Python/Ruby idiom of "value_that_may_be_null or
      default". If you want to use this form of "or", picking between two values rather than evaluating a
      condition, see the <code>//</code> operator below.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example81" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">42 and "a string"</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(true, false) or false</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">false</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(true, true) and (true, false)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">false</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">false</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[true, false | not]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[false, true]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="alternative-operator">
    <h3>Alternative operator: <code>//</code></h3>
    <p>
      The <code>//</code> operator produces all the values of its left-hand side that are neither
      <code>false</code> nor <code>null</code>, or, if the left-hand side produces no values other than
      <code>false</code> or <code>null</code>, then <code>//</code> produces all the values of its right-hand
      side.
    </p>
    <p>
      A filter of the form <code>a // b</code> produces all the results of <code>a</code> that are not
      <code>false</code> or <code>null</code>. If <code>a</code> produces no results, or no results other than
      <code>false</code> or <code>null</code>, then <code>a // b</code> produces the results of <code>b</code>.
    </p>
    <p>
      This is useful for providing defaults: <code>.foo // 1</code> will evaluate to <code>1</code> if there's
      no
      <code>.foo</code> element in the input. It's similar to how <code>or</code> is sometimes used in Python
      (jq's <code>or</code> operator is reserved for strictly Boolean operations).
    </p>
    <p>
      Note: <code>some_generator // defaults_here</code> is not the same as
      <code>some_generator | . // defaults_here</code>. The latter will produce default values for all
      non-<code>false</code>, non-<code>null</code>
      values of the left-hand side, while the former will not. Precedence rules can make this confusing. For
      example, in
      <code>false, 1 // 2</code> the left-hand side of <code>//</code> is <code>1</code>, not
      <code>false, 1</code> -- <code>false, 1 // 2</code> parses the same way as <code>false, (1 // 2)</code>.
      In
      <code>(false, null, 1) | . // 42</code> the left-hand side of <code>//</code> is <code>.</code>, which
      always produces just one value, while in <code>(false, null, 1) // 42</code> the left-hand side is a
      generator of three values, and since it produces a value other <code>false</code> and <code>null</code>,
      the
      default <code>42</code> is not produced.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example82" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">empty // 42</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">42</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.foo // 42</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"foo": 19}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">19</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.foo // 42</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">42</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(false, null, 1) // 42</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">1</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(false, null, 1) | . // 42</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">42</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">42</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">1</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="try-catch">
    <h3>try-catch</h3>
    <p>
      Errors can be caught by using <code>try EXP catch EXP</code>. The first expression is executed, and if
      it
      fails then the second is executed with the error message. The output of the handler, if any, is output
      as if
      it had been the output of the expression to try.
    </p>
    <p>The <code>try EXP</code> form uses <code>empty</code> as the exception handler.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example83" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">try .a catch ". is not an object"</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">". is not an object"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[]|try .a]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[{}, true, {"a":1}]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[null, 1]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">try error("some exception") catch .</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"some exception"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="breaking-out-of-control-structures">
    <h3>Breaking out of control structures</h3>
    <p>
      A convenient use of try/catch is to break out of control structures like <code>reduce</code>,
      <code>foreach</code>, <code>while</code>, and so on.
    </p>
    <p>For example:</p>
    <pre><code># Repeat an expression until it raises "break" as an
# error, then stop repeating without re-raising the error.
# But if the error caught is not "break" then re-raise it.
try repeat(exp) catch if .=="break" then empty else error
</code></pre>
    <p>jq has a syntax for named lexical labels to "break" or "go (back) to":</p>
    <pre><code>label $out | ... break $out ...
</code></pre>
    <p>
      The <code>break $label_name</code> expression will cause the program to act as though the nearest (to
      the
      left) <code>label $label_name</code> produced <code>empty</code>.
    </p>
    <p>
      The relationship between the <code>break</code> and corresponding <code>label</code> is lexical: the
      label
      has to be "visible" from the break.
    </p>
    <p>To break out of a <code>reduce</code>, for example:</p>
    <pre><code>label $out | reduce .[] as $item (null; if .==false then break $out else ... end)
</code></pre>
    <p>The following jq program produces a syntax error:</p>
    <pre><code>break $out
</code></pre>
    <p>because no label <code>$out</code> is visible.</p>
  </section>
  <section id="error-suppression-optional-operator">
    <h3>Error Suppression / Optional Operator: <code>?</code></h3>
    <p>The <code>?</code> operator, used as <code>EXP?</code>, is shorthand for <code>try EXP</code>.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example84" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[] | .a?]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[{}, true, {"a":1}]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[null, 1]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[.[] | tonumber?]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">["1", "invalid", "3", 4]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1, 3, 4]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
</section>
<!-- SECTION -->
<section id="regular-expressions">
  <h2>Regular expressions</h2>
  <p>
    jq uses the
    <a href="https://github.com/kkos/oniguruma/blob/master/doc/RE">Oniguruma regular expression library</a>, as
    do
    PHP, TextMate, Sublime Text, etc, so the description here will focus on jq specifics.
  </p>
  <p>
    Oniguruma supports several flavors of regular expression, so it is important to know that jq uses the
    <a href="https://github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md">"Perl NG" (Perl with named groups)</a>
    flavor.
  </p>
  <p>The jq regex filters are defined so that they can be used using one of these patterns:</p>
  <pre><code>STRING | FILTER(REGEX)
STRING | FILTER(REGEX; FLAGS)
STRING | FILTER([REGEX])
STRING | FILTER([REGEX, FLAGS])
</code></pre>
  <p>where:</p>
  <ul>
    <li>STRING, REGEX, and FLAGS are jq strings and subject to jq string interpolation;</li>
    <li>REGEX, after string interpolation, should be a valid regular expression;</li>
    <li>FILTER is one of <code>test</code>, <code>match</code>, or <code>capture</code>, as described below.
    </li>
  </ul>
  <p>
    Since REGEX must evaluate to a JSON string, some characters that are needed to form a regular expression
    must
    be escaped. For example, the regular expression <code>\s</code> signifying a whitespace character would be
    written as <code>"\\s"</code>.
  </p>
  <p>FLAGS is a string consisting of one of more of the supported flags:</p>
  <ul>
    <li><code>g</code> - Global search (find all matches, not just the first)</li>
    <li><code>i</code> - Case insensitive search</li>
    <li><code>m</code> - Multi line mode (<code>.</code> will match newlines)</li>
    <li><code>n</code> - Ignore empty matches</li>
    <li><code>p</code> - Both s and m modes are enabled</li>
    <li>
      <code>s</code> - Single line mode (<code>^</code> -&gt; <code>\A</code>, <code>$</code> -&gt;
      <code>\Z</code>)
    </li>
    <li><code>l</code> - Find longest possible matches</li>
    <li><code>x</code> - Extended regex format (ignore whitespace and comments)</li>
  </ul>
  <p>To match a whitespace with the <code>x</code> flag, use <code>\s</code>, e.g.</p>
  <pre><code>jq -n '"a b" | test("a\\sb"; "x")'
</code></pre>
  <p>Note that certain flags may also be specified within REGEX, e.g.</p>
  <pre><code>jq -n '("test", "TEst", "teST", "TEST") | test("(?i)te(?-i)st")'
</code></pre>
  <p>evaluates to: <code>true</code>, <code>true</code>, <code>false</code>, <code>false</code>.</p>
  <section id="test">
    <h3><code>test(val)</code>, <code>test(regex; flags)</code></h3>
    <p>
      Like <code>match</code>, but does not return match objects, only <code>true</code> or <code>false</code>
      for whether or not the regex matches the input.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example85" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">test("foo")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"foo"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.[] | test("a b c # spaces are ignored"; "ix")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">["xabcd", "ABC"]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="match">
    <h3><code>match(val)</code>, <code>match(regex; flags)</code></h3>
    <p><strong>match</strong> outputs an object for each match it finds. Matches have the following fields:</p>
    <ul>
      <li><code>offset</code> - offset in UTF-8 codepoints from the beginning of the input</li>
      <li><code>length</code> - length in UTF-8 codepoints of the match</li>
      <li><code>string</code> - the string that it matched</li>
      <li><code>captures</code> - an array of objects representing capturing groups.</li>
    </ul>
    <p>Capturing group objects have the following fields:</p>
    <ul>
      <li><code>offset</code> - offset in UTF-8 codepoints from the beginning of the input</li>
      <li><code>length</code> - length in UTF-8 codepoints of this capturing group</li>
      <li><code>string</code> - the string that was captured</li>
      <li><code>name</code> - the name of the capturing group (or <code>null</code> if it was unnamed)</li>
    </ul>
    <p>Capturing groups that did not match anything return an offset of -1</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example86" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">match("(abc)+"; "g")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"abc abc"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">
              {"offset": 0, "length": 3, "string": "abc", "captures": [{"offset": 0, "length": 3,
              "string":
              "abc", "name": null}]}
            </td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">
              {"offset": 4, "length": 3, "string": "abc", "captures": [{"offset": 4, "length": 3,
              "string":
              "abc", "name": null}]}
            </td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">match("foo")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"foo bar foo"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"offset": 0, "length": 3, "string": "foo", "captures": []}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">match(["foo", "ig"])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"foo bar FOO"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"offset": 0, "length": 3, "string": "foo", "captures": []}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"offset": 8, "length": 3, "string": "FOO", "captures": []}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">match("foo (?&lt;bar123&gt;bar)? foo"; "ig")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"foo bar foo foo foo"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">
              {"offset": 0, "length": 11, "string": "foo bar foo", "captures": [{"offset": 4,
              "length": 3,
              "string": "bar", "name": "bar123"}]}
            </td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">
              {"offset": 12, "length": 8, "string": "foo foo", "captures": [{"offset": -1, "length":
              0,
              "string": null, "name": "bar123"}]}
            </td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[ match("."; "g")] | length</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"abc"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">3</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="capture">
    <h3><code>capture(val)</code>, <code>capture(regex; flags)</code></h3>
    <p>
      Collects the named captures in a JSON object, with the name of each capture as the key, and the matched
      string as the corresponding value.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example87" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">capture("(?&lt;a&gt;[a-z]+)-(?&lt;n&gt;[0-9]+)")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"xyzzy-14"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{ "a": "xyzzy", "n": "14" }</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="scan">
    <h3><code>scan(regex)</code>, <code>scan(regex; flags)</code></h3>
    <p>
      Emit a stream of the non-overlapping substrings of the input that match the regex in accordance with the
      flags, if any have been specified. If there is no match, the stream is empty. To capture all the matches
      for
      each input string, use the idiom
      <code>[ expr ]</code>, e.g. <code>[ scan(regex) ]</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example88" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">scan("c")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"abcdefabc"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"c"</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">"c"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="split-2">
    <h3><code>split(regex; flags)</code></h3>
    <p>Splits an input string on each regex match.</p>
    <p>
      For backwards compatibility, when called with a single argument,
      <code>split</code> splits on a string, not a regex.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example89" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">split(", *"; null)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"ab,cd, ef"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">["ab","cd","ef"]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="splits">
    <h3><code>splits(regex)</code>, <code>splits(regex; flags)</code></h3>
    <p>
      These provide the same results as their
      <code>split</code> counterparts, but as a stream instead of an array.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example90" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">splits(", *")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"ab,cd, ef, gh"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"ab"</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">"cd"</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">"ef"</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">"gh"</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="sub">
    <h3><code>sub(regex; tostring)</code>, <code>sub(regex; tostring; flags)</code></h3>
    <p>
      Emit the string obtained by replacing the first match of regex in the input string with
      <code>tostring</code>, after interpolation. <code>tostring</code> should be a jq string or a stream of
      such
      strings, each of which may contain references to named captures. The named captures are, in effect,
      presented as a JSON object (as constructed by <code>capture</code>) to <code>tostring</code>, so a
      reference
      to a captured variable named "x" would take the form: <code>"\(.x)"</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example91" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">sub("[^a-z]*(?&lt;x&gt;[a-z]+)"; "Z\(.x)"; "g")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"123abc456def"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"ZabcZdef"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[sub("(?&lt;a&gt;.)"; "\(.a|ascii_upcase)",
              "\(.a|ascii_downcase)")]
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"aB"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">["AB","aB"]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="gsub">
    <h3><code>gsub(regex; tostring)</code>, <code>gsub(regex; tostring; flags)</code></h3>
    <p>
      <code>gsub</code> is like <code>sub</code> but all the non-overlapping occurrences of the regex are
      replaced
      by <code>tostring</code>, after interpolation. If the second argument is a stream of jq strings, then
      <code>gsub</code> will produce a corresponding stream of JSON strings.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example92" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">gsub("(?&lt;x&gt;.)[^a]*"; "+\(.x)-")</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"Abcabc"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">"+A-+a-"</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[gsub("p"; "a", "b")]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">"p"</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">["a","b"]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
</section>
<!-- SECTION -->
<section id="advanced-features">
  <h2>Advanced features</h2>
  <p>
    Variables are an absolute necessity in most programming languages, but they're relegated to an "advanced
    feature" in jq.
  </p>
  <p>
    In most languages, variables are the only means of passing around data. If you calculate a value, and you
    want
    to use it more than once, you'll need to store it in a variable. To pass a value to another part of the
    program, you'll need that part of the program to define a variable (as a function parameter, object member,
    or
    whatever) in which to place the data.
  </p>
  <p>
    It is also possible to define functions in jq, although this is is a feature whose biggest use is defining
    jq's standard library (many jq functions such as <code>map</code> and <code>select</code> are in fact
    written
    in jq).
  </p>
  <p>
    jq has reduction operators, which are very powerful but a bit tricky. Again, these are mostly used
    internally,
    to define some useful bits of jq's standard library.
  </p>
  <p>
    It may not be obvious at first, but jq is all about generators (yes, as often found in other languages).
    Some
    utilities are provided to help deal with generators.
  </p>
  <p>
    Some minimal I/O support (besides reading JSON from standard input, and writing JSON to standard output) is
    available.
  </p>
  <p>Finally, there is a module/library system.</p>
  <section id="variable-symbolic-binding-operator">
    <h3>Variable / Symbolic Binding Operator: <code>... as $identifier | ...</code></h3>
    <p>
      In jq, all filters have an input and an output, so manual plumbing is not necessary to pass a value from
      one
      part of a program to the next. Many expressions, for instance <code>a + b</code>, pass their input to
      two
      distinct subexpressions (here <code>a</code> and <code>b</code> are both passed the same input), so
      variables aren't usually necessary in order to use a value twice.
    </p>
    <p>
      For instance, calculating the average value of an array of numbers requires a few variables in most
      languages - at least one to hold the array, perhaps one for each element or for a loop counter. In jq,
      it's
      simply <code>add / length</code> - the <code>add</code> expression is given the array and produces its
      sum,
      and the <code>length</code> expression is given the array and produces its length.
    </p>
    <p>
      So, there's generally a cleaner way to solve most problems in jq than defining variables. Still,
      sometimes
      they do make things easier, so jq lets you define variables using
      <code>expression as $variable</code>. All variable names start with <code>$</code>. Here's a slightly
      uglier
      version of the array-averaging example:
    </p>
    <pre><code>length as $array_length | add / $array_length
</code></pre>
    <p>
      We'll need a more complicated problem to find a situation where using variables actually makes our lives
      easier.
    </p>
    <p>
      Suppose we have an array of blog posts, with "author" and "title" fields, and another object which is
      used
      to map author usernames to real names. Our input looks like:
    </p>
    <pre><code>{"posts": [{"title": "First post", "author": "anon"},
           {"title": "A well-written article", "author": "person1"}],
 "realnames": {"anon": "Anonymous Coward",
               "person1": "Person McPherson"}}
</code></pre>
    <p>We want to produce the posts with the author field containing a real name, as in:</p>
    <pre><code>{"title": "First post", "author": "Anonymous Coward"}
{"title": "A well-written article", "author": "Person McPherson"}
</code></pre>
    <p>
      We use a variable, $names, to store the realnames object, so that we can refer to it later when looking
      up
      author usernames:
    </p>
    <pre><code>.realnames as $names | .posts[] | {title, author: $names[.author]}
</code></pre>
    <p>
      The expression <code>exp as $x | ...</code> means: for each value of expression <code>exp</code>, run
      the
      rest of the pipeline with the entire original input, and with <code>$x</code> set to that value. Thus
      <code>as</code> functions as something of a foreach loop.
    </p>
    <p>
      Just as <code>{foo}</code> is a handy way of writing <code>{foo: .foo}</code>, so <code>{$foo}</code> is
      a
      handy way of writing <code>{foo: $foo}</code>.
    </p>
    <p>
      Multiple variables may be declared using a single
      <code>as</code> expression by providing a pattern that matches the structure of the input (this is known
      as
      "destructuring"):
    </p>
    <pre><code>. as {realnames: $names, posts: [$first, $second]} | ...
</code></pre>
    <p>
      The variable declarations in array patterns (e.g.,
      <code>. as [$first, $second]</code>) bind to the elements of the array in from the element at index zero
      on
      up, in order. When there is no value at the index for an array pattern element, <code>null</code> is
      bound
      to that variable.
    </p>
    <p>Variables are scoped over the rest of the expression that defines them, so</p>
    <pre><code>.realnames as $names | (.posts[] | {title, author: $names[.author]})
</code></pre>
    <p>will work, but</p>
    <pre><code>(.realnames as $names | .posts[]) | {title, author: $names[.author]}
</code></pre>
    <p>won't.</p>
    <p>
      For programming language theorists, it's more accurate to say that jq variables are lexically-scoped
      bindings. In particular there's no way to change the value of a binding; one can only setup a new
      binding
      with the same name, but which will not be visible where the old one was.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example93" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.bar as $x | .foo | . + $x</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"foo":10, "bar":200}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">210</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">. as $i|[(.*2|. as $i| $i), $i]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">5</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[10,5]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">. as [$a, $b, {c: $c}] | $a + $b + $c</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[2, 3, {"c": 4, "d": 5}]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">9</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.[] as [$a, $b] | {a: $a, b: $b}</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[0], [0, 1], [2, 1, 0]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":0,"b":null}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":0,"b":1}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":2,"b":1}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="destructuring-alternative-operator">
    <h3>Destructuring Alternative Operator: <code>?//</code></h3>
    <p>
      The destructuring alternative operator provides a concise mechanism for destructuring an input that can
      take
      one of several forms.
    </p>
    <p>
      Suppose we have an API that returns a list of resources and events associated with them, and we want to
      get
      the user_id and timestamp of the first event for each resource. The API (having been clumsily converted
      from
      XML) will only wrap the events in an array if the resource has multiple events:
    </p>
    <pre><code>{"resources": [{"id": 1, "kind": "widget", "events": {"action": "create", "user_id": 1, "ts": 13}},
               {"id": 2, "kind": "widget", "events": [{"action": "create", "user_id": 1, "ts": 14}, {"action": "destroy", "user_id": 1, "ts": 15}]}]}
</code></pre>
    <p>We can use the destructuring alternative operator to handle this structural change simply:</p>
    <pre><code>.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}
</code></pre>
    <p>Or, if we aren't sure if the input is an array of values or an object:</p>
    <pre><code>.[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...
</code></pre>
    <p>
      Each alternative need not define all of the same variables, but all named variables will be available to
      the
      subsequent expression. Variables not matched in the alternative that succeeded will be
      <code>null</code>:
    </p>
    <pre><code>.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}
</code></pre>
    <p>
      Additionally, if the subsequent expression returns an error, the alternative operator will attempt to
      try
      the next binding. Errors that occur during the final alternative are passed through.
    </p>
    <pre><code>[[3]] | .[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end
</code></pre>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example94" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">
              .[] as {$a, $b, c: {$d, $e}} ?// {$a, $b, c: [{$d, $e}]} | {$a, $b, $d, $e}
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
            </td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":1,"b":2,"d":3,"e":4}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":1,"b":2,"d":3,"e":4}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.[] as {$a, $b, c: {$d}} ?// {$a, $b, c: [{$e}]} | {$a, $b, $d,
              $e}
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
            </td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":1,"b":2,"d":3,"e":null}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":1,"b":2,"d":null,"e":4}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">
              .[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[3]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":null,"b":3}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="defining-functions">
    <h3>Defining Functions</h3>
    <p>You can give a filter a name using "def" syntax:</p>
    <pre><code>def increment: . + 1;
</code></pre>
    <p>
      From then on, <code>increment</code> is usable as a filter just like a builtin function (in fact, this
      is
      how many of the builtins are defined). A function may take arguments:
    </p>
    <pre><code>def map(f): [.[] | f];
</code></pre>
    <p>
      Arguments are passed as <em>filters</em> (functions with no arguments), <em>not</em> as values. The same
      argument may be referenced multiple times with different inputs (here <code>f</code> is run for each
      element
      of the input array). Arguments to a function work more like callbacks than like value arguments. This is
      important to understand. Consider:
    </p>
    <pre><code>def foo(f): f|f;
5|foo(.*2)
</code></pre>
    <p>
      The result will be 20 because <code>f</code> is <code>.*2</code>, and during the first invocation of
      <code>f</code> <code>.</code> will be 5, and the second time it will be 10 (5 * 2), so the result will
      be
      20. Function arguments are filters, and filters expect an input when invoked.
    </p>
    <p>If you want the value-argument behaviour for defining simple functions, you can just use a variable:</p>
    <pre><code>def addvalue(f): f as $f | map(. + $f);
</code></pre>
    <p>Or use the short-hand:</p>
    <pre><code>def addvalue($f): ...;
</code></pre>
    <p>
      With either definition, <code>addvalue(.foo)</code> will add the current input's <code>.foo</code> field
      to
      each element of the array. Do note that calling <code>addvalue(.[])</code> will cause the
      <code>map(. + $f)</code> part to be evaluated once per value in the value of <code>.</code> at the call
      site.
    </p>
    <p>
      Multiple definitions using the same function name are allowed. Each re-definition replaces the previous
      one
      for the same number of function arguments, but only for references from functions (or main program)
      subsequent to the re-definition. See also the section below on scoping.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example95" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">def addvalue(f): . + [f]; map(addvalue(.[0]))</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[1,2],[10,20]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[[1,2,1], [10,20,10]]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">def addvalue(f): f as $x | map(. + $x); addvalue(.[0])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[1,2],[10,20]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[[1,2,1,2], [10,20,1,2]]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="scoping">
    <h3>Scoping</h3>
    <p>
      There are two types of symbols in jq: value bindings (a.k.a., "variables"), and functions. Both are
      scoped
      lexically, with expressions being able to refer only to symbols that have been defined "to the left" of
      them. The only exception to this rule is that functions can refer to themselves so as to be able to
      create
      recursive functions.
    </p>
    <p>
      For example, in the following expression there is a binding which is visible "to the right" of it,
      <code>... | .*3 as $times_three | [. + $times_three] | ...</code>, but not "to the left". Consider this
      expression now, <code>... | (.*3 as $times_three | [. + $times_three]) | ...</code>: here the binding
      <code>$times_three</code> is <em>not</em> visible past the closing parenthesis.
    </p>
  </section>
  <section id="isempty">
    <h3><code>isempty(exp)</code></h3>
    <p>Returns true if <code>exp</code> produces no outputs, false otherwise.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example96" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">isempty(empty)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">isempty(.[])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">true</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">isempty(.[])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">false</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="limit">
    <h3><code>limit(n; exp)</code></h3>
    <p>The <code>limit</code> function extracts up to <code>n</code> outputs from <code>exp</code>.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example97" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[limit(3;.[])]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[0,1,2,3,4,5,6,7,8,9]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[0,1,2]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="first-last-nth-2">
    <h3><code>first(expr)</code>, <code>last(expr)</code>, <code>nth(n; expr)</code></h3>
    <p>
      The <code>first(expr)</code> and <code>last(expr)</code> functions extract the first and last values
      from
      <code>expr</code>, respectively.
    </p>
    <p>
      The <code>nth(n; expr)</code> function extracts the nth value output by <code>expr</code>. Note that
      <code>nth(n; expr)</code> doesn't support negative values of <code>n</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example98" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[first(range(.)), last(range(.)), nth(./2; range(.))]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">10</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[0,9,5]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="first-last-nth-1">
    <h3><code>first</code>, <code>last</code>, <code>nth(n)</code></h3>
    <p>
      The <code>first</code> and <code>last</code> functions extract the first and last values from any array
      at
      <code>.</code>.
    </p>
    <p>The <code>nth(n)</code> function extracts the nth value of any array at <code>.</code>.</p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example99" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">[range(.)]|[first, last, nth(5)]</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">10</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[0,9,5]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="reduce">
    <h3><code>reduce</code></h3>
    <p>
      The <code>reduce</code> syntax allows you to combine all of the results of an expression by accumulating
      them into a single answer. The form is <code>reduce EXP as $var (INIT; UPDATE)</code>. As an example,
      we'll
      pass <code>[1,2,3]</code> to this expression:
    </p>
    <pre><code>reduce .[] as $item (0; . + $item)
</code></pre>
    <p>
      For each result that <code>.[]</code> produces, <code>. + $item</code> is run to accumulate a running
      total,
      starting from 0 as the input value. In this example, <code>.[]</code> produces the results
      <code>1</code>,
      <code>2</code>, and <code>3</code>, so the effect is similar to running something like this:
    </p>
    <pre><code>0 | 1 as $item | . + $item |
    2 as $item | . + $item |
    3 as $item | . + $item
</code></pre>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example100" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">reduce .[] as $item (0; . + $item)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3,4,5]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">15</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">reduce .[] as [$i,$j] (0; . + $i * $j)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[[1,2],[3,4],[5,6]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">44</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">reduce .[] as {$x,$y} (null; .x += $x | .y += [$y])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[{"x":"a","y":1},{"x":"b","y":2},{"x":"c","y":3}]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"x":"abc","y":[1,2,3]}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="foreach">
    <h3><code>foreach</code></h3>
    <p>
      The <code>foreach</code> syntax is similar to <code>reduce</code>, but intended to allow the
      construction of
      <code>limit</code> and reducers that produce intermediate results.
    </p>
    <p>
      The form is
      <code>foreach EXP as $var (INIT; UPDATE; EXTRACT)</code>. As an example, we'll pass <code>[1,2,3]</code>
      to this expression:
    </p>
    <pre><code>foreach .[] as $item (0; . + $item; [$item, . * 2])
</code></pre>
    <p>
      Like the <code>reduce</code> syntax, <code>. + $item</code> is run for each result that
      <code>.[]</code> produces, but <code>[$item, . * 2]</code> is run for each intermediate values. In this
      example, since the intermediate values are <code>1</code>, <code>3</code>, and <code>6</code>, the
      <code>foreach</code> expression produces <code>[1,2]</code>, <code>[2,6]</code>, and <code>[3,12]</code>.
      So
      the effect is similar to running something like this:
    </p>
    <pre><code>0 | 1 as $item | . + $item | [$item, . * 2],
    2 as $item | . + $item | [$item, . * 2],
    3 as $item | . + $item | [$item, . * 2]
</code></pre>
    <p>
      When <code>EXTRACT</code> is omitted, the identity filter is used. That is, it outputs the intermediate
      values as they are.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example101" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">foreach .[] as $item (0; . + $item)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3,4,5]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">1</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">3</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">6</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">10</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">15</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">foreach .[] as $item (0; . + $item; [$item, . * 2])</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[1,2,3,4,5]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,2]</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">[2,6]</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">[3,12]</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">[4,20]</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">[5,30]</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">foreach .[] as $item (0; . + 1; {index: ., $item})</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">["foo", "bar", "baz"]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"index":1,"item":"foo"}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"index":2,"item":"bar"}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"index":3,"item":"baz"}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="recursion">
    <h3>Recursion</h3>
    <p>
      As described above, <code>recurse</code> uses recursion, and any jq function can be recursive. The
      <code>while</code> builtin is also implemented in terms of recursion.
    </p>
    <p>
      Tail calls are optimized whenever the expression to the left of the recursive call outputs its last
      value.
      In practice this means that the expression to the left of the recursive call should not produce more
      than
      one output for each input.
    </p>
    <p>For example:</p>
    <pre><code>def recurse(f): def r: ., (f | select(. != null) | r); r;def while(cond; update):
  def _while:
    if cond then ., (update | _while) else empty end;
  _while;def repeat(exp):
  def _repeat:
    exp, _repeat;
  _repeat;
</code></pre>
  </section>
  <section id="generators-and-iterators">
    <h3>Generators and iterators</h3>
    <p>
      Some jq operators and functions are actually generators in that they can produce zero, one, or more
      values
      for each input, just as one might expect in other programming languages that have generators. For
      example,
      <code>.[]</code> generates all the values in its input (which must be an array or an object),
      <code>range(0; 10)</code> generates the integers between 0 and 10, and so on.
    </p>
    <p>
      Even the comma operator is a generator, generating first the values generated by the expression to the
      left
      of the comma, then the values generated by the expression on the right of the comma.
    </p>
    <p>
      The <code>empty</code> builtin is the generator that produces zero outputs. The <code>empty</code>
      builtin backtracks to the preceding generator expression.
    </p>
    <p>
      All jq functions can be generators just by using builtin generators. It is also possible to construct
      new
      generators using only recursion and the comma operator. If recursive calls are "in tail position" then
      the
      generator will be efficient. In the example below the recursive call by <code>_range</code> to itself is
      in
      tail position. The example shows off three advanced topics: tail recursion, generator construction, and
      sub-functions.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example102" class="mx-3 small d-print-block collapse show">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">
              def range(init; upto; by): def _range: if (by &gt; 0 and . &lt; upto) or (by &lt; 0 and
              . &gt;
              upto) then ., ((.+by)|_range) else . end; if by == 0 then init else init|_range end |
              select((by
              &gt; 0 and . &lt; upto) or (by &lt; 0 and . &gt; upto)); range(0; 10; 3)
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">0</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">3</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">6</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">9</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">
              def while(cond; update): def _while: if cond then ., (update | _while) else empty end;
              _while;
              [while(.&lt;100; .*2)]
            </td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">1</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,2,4,8,16,32,64]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
</section>
<!-- SECTION -->
<section id="math">
  <h2>Math</h2>
  <p>jq currently only has IEEE754 double-precision (64-bit) floating point number support.</p>
  <p>
    Besides simple arithmetic operators such as <code>+</code>, jq also has most standard math functions from
    the
    C math library. C math functions that take a single input argument (e.g., <code>sin()</code>) are available
    as
    zero-argument jq functions. C math functions that take two input arguments (e.g., <code>pow()</code>) are
    available as two-argument jq functions that ignore <code>.</code>. C math functions that take three input
    arguments are available as three-argument jq functions that ignore <code>.</code>.
  </p>
  <p>
    Availability of standard math functions depends on the availability of the corresponding math functions in
    your operating system and C math library. Unavailable math functions will be defined but will raise an
    error.
  </p>
  <p>
    One-input C math functions: <code>acos</code> <code>acosh</code> <code>asin</code> <code>asinh</code>
    <code>atan</code> <code>atanh</code> <code>cbrt</code> <code>ceil</code> <code>cos</code> <code>cosh</code>
    <code>erf</code> <code>erfc</code> <code>exp</code> <code>exp10</code> <code>exp2</code> <code>expm1</code>
    <code>fabs</code> <code>floor</code> <code>gamma</code> <code>j0</code> <code>j1</code> <code>lgamma</code>
    <code>log</code> <code>log10</code> <code>log1p</code> <code>log2</code> <code>logb</code>
    <code>nearbyint</code> <code>pow10</code> <code>rint</code> <code>round</code> <code>significand</code>
    <code>sin</code> <code>sinh</code> <code>sqrt</code> <code>tan</code> <code>tanh</code> <code>tgamma</code>
    <code>trunc</code> <code>y0</code> <code>y1</code>.
  </p>
  <p>
    Two-input C math functions: <code>atan2</code> <code>copysign</code> <code>drem</code> <code>fdim</code>
    <code>fmax</code> <code>fmin</code> <code>fmod</code> <code>frexp</code> <code>hypot</code> <code>jn</code>
    <code>ldexp</code> <code>modf</code> <code>nextafter</code> <code>nexttoward</code> <code>pow</code>
    <code>remainder</code> <code>scalb</code> <code>scalbln</code> <code>yn</code>.
  </p>
  <p>Three-input C math functions: <code>fma</code>.</p>
  <p>See your system's manual for more information on each of these.</p>
</section>
<!-- SECTION -->
<section id="assignment">
  <h2>Assignment</h2>
  <p>
    Assignment works a little differently in jq than in most programming languages. jq doesn't distinguish
    between
    references to and copies of something - two objects or arrays are either equal or not equal, without any
    further notion of being "the same object" or "not the same object".
  </p>
  <p>
    If an object has two fields which are arrays, <code>.foo</code> and <code>.bar</code>, and you append
    something to <code>.foo</code>, then <code>.bar</code> will not get bigger, even if you've previously set
    <code>.bar = .foo</code>. If you're used to programming in languages like Python, Java, Ruby, JavaScript,
    etc.
    then you can think of it as though jq does a full deep copy of every object before it does the assignment
    (for
    performance it doesn't actually do that, but that's the general idea).
  </p>
  <p>
    This means that it's impossible to build circular values in jq (such as an array whose first element is
    itself). This is quite intentional, and ensures that anything a jq program can produce can be represented in
    JSON.
  </p>
  <p>
    All the assignment operators in jq have path expressions on the left-hand side (LHS). The right-hand side
    (RHS) provides values to set to the paths named by the LHS path expressions.
  </p>
  <p>
    Values in jq are always immutable. Internally, assignment works by using a reduction to compute new,
    replacement values for
    <code>.</code> that have had all the desired assignments applied to <code>.</code>, then outputting the
    modified value. This might be made clear by this example: <code>{a:{b:{c:1}}} | (.a.b|=3), .</code>. This
    will
    output <code>{"a":{"b":3}}</code> and <code>{"a":{"b":{"c":1}}}</code> because the last sub-expression,
    <code>.</code>, sees the original value, not the modified value.
  </p>
  <p>
    Most users will want to use modification assignment operators, such as
    <code>|=</code> or <code>+=</code>, rather than <code>=</code>.
  </p>
  <p>
    Note that the LHS of assignment operators refers to a value in
    <code>.</code>. Thus <code>$var.foo = 1</code> won't work as expected (<code>$var.foo</code> is not a valid
    or
    useful path expression in <code>.</code>); use <code>$var | .foo = 1</code> instead.
  </p>
  <p>
    Note too that <code>.a,.b=0</code> does not set <code>.a</code> and <code>.b</code>, but
    <code>(.a,.b)=0</code> sets both.
  </p>
  <section id="update-assignment">
    <h3>Update-assignment: <code>|=</code></h3>
    <p>
      This is the "update" operator <code>|=</code>. It takes a filter on the right-hand side and works out
      the
      new value for the property of <code>.</code> being assigned to by running the old value through this
      expression. For instance, <code>(.foo, .bar) |= .+1</code> will build an object with the
      <code>foo</code> field set to the input's <code>foo</code> plus 1, and the <code>bar</code> field set to
      the
      input's <code>bar</code> plus 1.
    </p>
    <p>
      The left-hand side can be any general path expression; see
      <code>path()</code>.
    </p>
    <p>
      Note that the left-hand side of <code>|=</code> refers to a value in <code>.</code>. Thus
      <code>$var.foo |= . + 1</code> won't work as expected (<code>$var.foo</code> is not a valid or useful
      path
      expression in <code>.</code>); use <code>$var | .foo |= . + 1</code> instead.
    </p>
    <p>
      If the right-hand side outputs no values (i.e., <code>empty</code>), then the left-hand side path will
      be
      deleted, as with <code>del(path)</code>.
    </p>
    <p>
      If the right-hand side outputs multiple values, only the first one will be used (COMPATIBILITY NOTE: in
      jq
      1.5 and earlier releases, it used to be that only the last one was used).
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example106" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(..|select(type=="boolean")) |= if . then 1 else 0 end</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[true,false,[5,true,[true,[false]],false]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,0,[5,1,[1,[0]],0]]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="arithmetic-update-assignment">
    <h3>
      Arithmetic update-assignment: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>,
      <code>%=</code>, <code>//=</code>
    </h3>
    <p>
      jq has a few operators of the form <code>a op= b</code>, which are all equivalent to
      <code>a |= . op b</code>. So, <code>+= 1</code> can be used to increment values, being the same as
      <code>|= . + 1</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example107" class="mx-3 small d-print-block collapse show">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.foo += 1</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"foo": 42}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"foo": 43}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="plain-assignment">
    <h3>Plain assignment: <code>=</code></h3>
    <p>
      This is the plain assignment operator. Unlike the others, the input to the right-hand side (RHS) is the
      same
      as the input to the left-hand side (LHS) rather than the value at the LHS path, and all values output by
      the
      RHS will be used (as shown below).
    </p>
    <p>
      If the RHS of <code>=</code> produces multiple values, then for each such value jq will set the paths on
      the
      left-hand side to the value and then it will output the modified <code>.</code>. For example,
      <code>(.a,.b) = range(2)</code> outputs <code>{"a":0,"b":0}</code>, then <code>{"a":1,"b":1}</code>. The
      "update" assignment forms (see above) do not do this.
    </p>
    <p>This example should show the difference between <code>=</code> and <code>|=</code>:</p>
    <p>Provide input <code>{"a": {"b": 10}, "b": 20}</code> to the programs</p>
    <pre><code>.a = .b
</code></pre>
    <p>and</p>
    <pre><code>.a |= .b
</code></pre>
    <p>
      The former will set the <code>a</code> field of the input to the <code>b</code> field of the input, and
      produce the output <code>{"a": 20, "b": 20}</code>. The latter will set the <code>a</code> field of the
      input to the <code>a</code> field's <code>b</code> field, producing <code>{"a": 10, "b": 20}</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example108" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.a = .b</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"a": {"b": 10}, "b": 20}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":20,"b":20}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.a |= .b</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"a": {"b": 10}, "b": 20}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":10,"b":20}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(.a, .b) = range(3)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":0,"b":0}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":1,"b":1}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":2,"b":2}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(.a, .b) |= range(3)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":0,"b":0}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="complex-assignments">
    <h3>Complex assignments</h3>
    <p>
      Lots more things are allowed on the left-hand side of a jq assignment than in most languages. We've
      already
      seen simple field accesses on the left hand side, and it's no surprise that array accesses work just as
      well:
    </p>
    <pre><code>.posts[0].title = "JQ Manual"
</code></pre>
    <p>
      What may come as a surprise is that the expression on the left may produce multiple results, referring
      to
      different points in the input document:
    </p>
    <pre><code>.posts[].comments |= . + ["this is great"]
</code></pre>
    <p>
      That example appends the string "this is great" to the "comments" array of each post in the input (where
      the
      input is an object with a field "posts" which is an array of posts).
    </p>
    <p>
      When jq encounters an assignment like 'a = b', it records the "path" taken to select a part of the input
      document while executing a. This path is then used to find which part of the input to change while
      executing
      the assignment. Any filter may be used on the left-hand side of an equals - whichever paths it selects
      from
      the input will be where the assignment is performed.
    </p>
    <p>
      This is a very powerful operation. Suppose we wanted to add a comment to blog posts, using the same
      "blog"
      input above. This time, we only want to comment on the posts written by "stedolan". We can find those
      posts
      using the "select" function described earlier:
    </p>
    <pre><code>.posts[] | select(.author == "stedolan")</code></pre>
    <p>
      The paths provided by this operation point to each of the posts that "stedolan" wrote, and we can
      comment on
      each of them in the same way that we did before:
    </p>
    <pre><code>(.posts[] | select(.author == "stedolan") | .comments) |= . + ["terrible."]</code></pre>
  </section>
</section>
