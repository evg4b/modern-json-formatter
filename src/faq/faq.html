<!-- SECTION -->
<section id="math">
  <h2>Math</h2>
  <p>jq currently only has IEEE754 double-precision (64-bit) floating point number support.</p>
  <p>
    Besides simple arithmetic operators such as <code>+</code>, jq also has most standard math functions from
    the
    C math library. C math functions that take a single input argument (e.g., <code>sin()</code>) are available
    as
    zero-argument jq functions. C math functions that take two input arguments (e.g., <code>pow()</code>) are
    available as two-argument jq functions that ignore <code>.</code>. C math functions that take three input
    arguments are available as three-argument jq functions that ignore <code>.</code>.
  </p>
  <p>
    Availability of standard math functions depends on the availability of the corresponding math functions in
    your operating system and C math library. Unavailable math functions will be defined but will raise an
    error.
  </p>
  <p>
    One-input C math functions: <code>acos</code> <code>acosh</code> <code>asin</code> <code>asinh</code>
    <code>atan</code> <code>atanh</code> <code>cbrt</code> <code>ceil</code> <code>cos</code> <code>cosh</code>
    <code>erf</code> <code>erfc</code> <code>exp</code> <code>exp10</code> <code>exp2</code> <code>expm1</code>
    <code>fabs</code> <code>floor</code> <code>gamma</code> <code>j0</code> <code>j1</code> <code>lgamma</code>
    <code>log</code> <code>log10</code> <code>log1p</code> <code>log2</code> <code>logb</code>
    <code>nearbyint</code> <code>pow10</code> <code>rint</code> <code>round</code> <code>significand</code>
    <code>sin</code> <code>sinh</code> <code>sqrt</code> <code>tan</code> <code>tanh</code> <code>tgamma</code>
    <code>trunc</code> <code>y0</code> <code>y1</code>.
  </p>
  <p>
    Two-input C math functions: <code>atan2</code> <code>copysign</code> <code>drem</code> <code>fdim</code>
    <code>fmax</code> <code>fmin</code> <code>fmod</code> <code>frexp</code> <code>hypot</code> <code>jn</code>
    <code>ldexp</code> <code>modf</code> <code>nextafter</code> <code>nexttoward</code> <code>pow</code>
    <code>remainder</code> <code>scalb</code> <code>scalbln</code> <code>yn</code>.
  </p>
  <p>Three-input C math functions: <code>fma</code>.</p>
  <p>See your system's manual for more information on each of these.</p>
</section>
<!-- SECTION -->
<section id="assignment">
  <h2>Assignment</h2>
  <p>
    Assignment works a little differently in jq than in most programming languages. jq doesn't distinguish
    between
    references to and copies of something - two objects or arrays are either equal or not equal, without any
    further notion of being "the same object" or "not the same object".
  </p>
  <p>
    If an object has two fields which are arrays, <code>.foo</code> and <code>.bar</code>, and you append
    something to <code>.foo</code>, then <code>.bar</code> will not get bigger, even if you've previously set
    <code>.bar = .foo</code>. If you're used to programming in languages like Python, Java, Ruby, JavaScript,
    etc.
    then you can think of it as though jq does a full deep copy of every object before it does the assignment
    (for
    performance it doesn't actually do that, but that's the general idea).
  </p>
  <p>
    This means that it's impossible to build circular values in jq (such as an array whose first element is
    itself). This is quite intentional, and ensures that anything a jq program can produce can be represented in
    JSON.
  </p>
  <p>
    All the assignment operators in jq have path expressions on the left-hand side (LHS). The right-hand side
    (RHS) provides values to set to the paths named by the LHS path expressions.
  </p>
  <p>
    Values in jq are always immutable. Internally, assignment works by using a reduction to compute new,
    replacement values for
    <code>.</code> that have had all the desired assignments applied to <code>.</code>, then outputting the
    modified value. This might be made clear by this example: <code>{a:{b:{c:1}}} | (.a.b|=3), .</code>. This
    will
    output <code>{"a":{"b":3}}</code> and <code>{"a":{"b":{"c":1}}}</code> because the last sub-expression,
    <code>.</code>, sees the original value, not the modified value.
  </p>
  <p>
    Most users will want to use modification assignment operators, such as
    <code>|=</code> or <code>+=</code>, rather than <code>=</code>.
  </p>
  <p>
    Note that the LHS of assignment operators refers to a value in
    <code>.</code>. Thus <code>$var.foo = 1</code> won't work as expected (<code>$var.foo</code> is not a valid
    or
    useful path expression in <code>.</code>); use <code>$var | .foo = 1</code> instead.
  </p>
  <p>
    Note too that <code>.a,.b=0</code> does not set <code>.a</code> and <code>.b</code>, but
    <code>(.a,.b)=0</code> sets both.
  </p>
  <section id="update-assignment">
    <h3>Update-assignment: <code>|=</code></h3>
    <p>
      This is the "update" operator <code>|=</code>. It takes a filter on the right-hand side and works out
      the
      new value for the property of <code>.</code> being assigned to by running the old value through this
      expression. For instance, <code>(.foo, .bar) |= .+1</code> will build an object with the
      <code>foo</code> field set to the input's <code>foo</code> plus 1, and the <code>bar</code> field set to
      the
      input's <code>bar</code> plus 1.
    </p>
    <p>
      The left-hand side can be any general path expression; see
      <code>path()</code>.
    </p>
    <p>
      Note that the left-hand side of <code>|=</code> refers to a value in <code>.</code>. Thus
      <code>$var.foo |= . + 1</code> won't work as expected (<code>$var.foo</code> is not a valid or useful
      path
      expression in <code>.</code>); use <code>$var | .foo |= . + 1</code> instead.
    </p>
    <p>
      If the right-hand side outputs no values (i.e., <code>empty</code>), then the left-hand side path will
      be
      deleted, as with <code>del(path)</code>.
    </p>
    <p>
      If the right-hand side outputs multiple values, only the first one will be used (COMPATIBILITY NOTE: in
      jq
      1.5 and earlier releases, it used to be that only the last one was used).
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example106" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(..|select(type=="boolean")) |= if . then 1 else 0 end</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">[true,false,[5,true,[true,[false]],false]]</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">[1,0,[5,1,[1,[0]],0]]</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="arithmetic-update-assignment">
    <h3>
      Arithmetic update-assignment: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>,
      <code>%=</code>, <code>//=</code>
    </h3>
    <p>
      jq has a few operators of the form <code>a op= b</code>, which are all equivalent to
      <code>a |= . op b</code>. So, <code>+= 1</code> can be used to increment values, being the same as
      <code>|= . + 1</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example107" class="mx-3 small d-print-block collapse show">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.foo += 1</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"foo": 42}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"foo": 43}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="plain-assignment">
    <h3>Plain assignment: <code>=</code></h3>
    <p>
      This is the plain assignment operator. Unlike the others, the input to the right-hand side (RHS) is the
      same
      as the input to the left-hand side (LHS) rather than the value at the LHS path, and all values output by
      the
      RHS will be used (as shown below).
    </p>
    <p>
      If the RHS of <code>=</code> produces multiple values, then for each such value jq will set the paths on
      the
      left-hand side to the value and then it will output the modified <code>.</code>. For example,
      <code>(.a,.b) = range(2)</code> outputs <code>{"a":0,"b":0}</code>, then <code>{"a":1,"b":1}</code>. The
      "update" assignment forms (see above) do not do this.
    </p>
    <p>This example should show the difference between <code>=</code> and <code>|=</code>:</p>
    <p>Provide input <code>{"a": {"b": 10}, "b": 20}</code> to the programs</p>
    <pre><code>.a = .b
</code></pre>
    <p>and</p>
    <pre><code>.a |= .b
</code></pre>
    <p>
      The former will set the <code>a</code> field of the input to the <code>b</code> field of the input, and
      produce the output <code>{"a": 20, "b": 20}</code>. The latter will set the <code>a</code> field of the
      input to the <code>a</code> field's <code>b</code> field, producing <code>{"a": 10, "b": 20}</code>.
    </p>
    <div class="pb-3">
      <h4 class="examples">Examples:</h4>
      <div id="example108" class="collapse mx-3 small d-print-block">
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.a = .b</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"a": {"b": 10}, "b": 20}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":20,"b":20}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">.a |= .b</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">{"a": {"b": 10}, "b": 20}</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":10,"b":20}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(.a, .b) = range(3)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":0,"b":0}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":1,"b":1}</td>
          </tr>
          <tr>
            <th></th>
            <td class="font-monospace">{"a":2,"b":2}</td>
          </tr>
          </tbody>
        </table>
        <table class="table table-borderless table-sm w-auto">
          <tbody>
          <tr>
            <th class="pe-3">Query</th>
            <td class="font-monospace">(.a, .b) |= range(3)</td>
          </tr>
          <tr>
            <th>Input</th>
            <td class="font-monospace">null</td>
          </tr>
          <tr>
            <th>Output</th>
            <td class="font-monospace">{"a":0,"b":0}</td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <section id="complex-assignments">
    <h3>Complex assignments</h3>
    <p>
      Lots more things are allowed on the left-hand side of a jq assignment than in most languages. We've
      already
      seen simple field accesses on the left hand side, and it's no surprise that array accesses work just as
      well:
    </p>
    <pre><code>.posts[0].title = "JQ Manual"
</code></pre>
    <p>
      What may come as a surprise is that the expression on the left may produce multiple results, referring
      to
      different points in the input document:
    </p>
    <pre><code>.posts[].comments |= . + ["this is great"]
</code></pre>
    <p>
      That example appends the string "this is great" to the "comments" array of each post in the input (where
      the
      input is an object with a field "posts" which is an array of posts).
    </p>
    <p>
      When jq encounters an assignment like 'a = b', it records the "path" taken to select a part of the input
      document while executing a. This path is then used to find which part of the input to change while
      executing
      the assignment. Any filter may be used on the left-hand side of an equals - whichever paths it selects
      from
      the input will be where the assignment is performed.
    </p>
    <p>
      This is a very powerful operation. Suppose we wanted to add a comment to blog posts, using the same
      "blog"
      input above. This time, we only want to comment on the posts written by "stedolan". We can find those
      posts
      using the "select" function described earlier:
    </p>
    <pre><code>.posts[] | select(.author == "stedolan")</code></pre>
    <p>
      The paths provided by this operation point to each of the posts that "stedolan" wrote, and we can
      comment on
      each of them in the same way that we did before:
    </p>
    <pre><code>(.posts[] | select(.author == "stedolan") | .comments) |= . + ["terrible."]</code></pre>
  </section>
</section>
